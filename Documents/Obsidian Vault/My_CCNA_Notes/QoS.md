## 1. 知识点定位

QoS 在 CCNA 200-301 中属于 **必考内容**，归属于考试大纲第 5 部分 "Security Fundamentals" 旁边的 **"IP Services"** 模块（约占考试 10%）。

考试权重：**中高频**。不会像 OSPF/STP 那样出大量深度题，但几乎每次考试都会出 2-4 题。考法以 **概念选择题** 为主，偶尔出情景题（给你一个网络场景，问你应该用哪种 QoS 机制或哪个 DSCP 值）。

CCNA 对 QoS 的要求是：**理解模型、认识标记值、知道机制分类**，不要求你配置复杂的 QoS policy-map（那是 CCNP/CCIE 的事）。

---

## 2. 核心概念

### QoS 解决什么问题

网络带宽是有限的。当多种流量（语音、视频、文件下载、Web 浏览）竞争同一条链路时，如果不加区分，所有流量平等排队，结果就是：

- 语音出现断续、延迟
- 视频出现卡顿、花屏
- 关键业务应用响应变慢

QoS 的本质就是：**在带宽不足时，决定谁先走、谁慢走、谁被丢弃**。

注意：QoS **不创造带宽**，它只是**管理现有带宽的分配策略**。

### QoS 关注的四个关键指标

| 指标 | 含义 | 对什么流量敏感 |
| --- | --- | --- |
| **Bandwidth（带宽）** | 链路可用的总吞吐量 | 大文件传输 |
| **Delay（延迟）** | 数据从源到目的所花时间 | 语音、视频 |
| **Jitter（抖动）** | 延迟的变化幅度（不稳定性） | 语音、实时视频 |
| **Loss（丢包）** | 传输过程中丢失的数据包比例 | 所有流量，语音尤其敏感 |

语音流量（VoIP）对这四个指标的要求最严格：

- 单向延迟 ≤ 150ms
- 抖动 ≤ 30ms
- 丢包 ≤ 1%

**考试常考**：问你语音流量对哪个指标最敏感，答案是 **delay 和 jitter**。

---

## 3. 工作原理（一步一步）

QoS 的整个工作流程可以分为三大步骤，按数据包从进入到离开设备的顺序：

### 第一步：Classification（分类）

数据包进入设备后，首先要识别"这是什么流量"。

分类依据可以是：

- **Layer 2**：CoS（Class of Service），位于 802.1Q VLAN tag 的 3-bit PCP 字段，取值 0-7
- **Layer 3**：DSCP（Differentiated Services Code Point），位于 IP header 的 ToS 字段中的前 6 bits，取值 0-63
- **Layer 4**：端口号（比如 UDP 5060 = SIP 语音信令）
- **NBAR**：基于深度包检测识别应用

**考试重点在 CoS 和 DSCP。**

### 第二步：Marking（标记）

识别出流量类型后，在数据包头部写入一个标记值，这样后续每一跳设备都能快速识别该流量的优先级，而不需要重新做深度分类。

标记发生的位置：

```
Layer 2 标记：CoS（3 bits，在 802.1Q tag 中）
  - 取值范围：0 - 7
  - 只在有 trunk（802.1Q tag）时存在
  - 穿越非 trunk 链路时 CoS 会丢失

Layer 3 标记：DSCP（6 bits，在 IP header 的 DS 字段中）
  - 取值范围：0 - 63
  - 端到端保持（只要中间设备不改写）
  - 这是 CCNA 考试最关注的标记方式
```

**关键：推荐尽可能在靠近源的位置做标记（Trust Boundary 概念）。** 通常在接入层交换机上标记，而不是在核心层。

### 第三步：Queuing / Scheduling / Congestion Management（排队与调度）

标记完成后，当出接口发生拥塞时，设备根据标记值决定如何处理队列中的数据包。

主要机制：

| 机制 | 作用 | CCNA 要求 |
| --- | --- | --- |
| **FIFO** | 先进先出，无优先级区分 | 了解即可，默认行为 |
| **Weighted Fair Queuing (WFQ)** | 按权重公平分配带宽 | 知道概念 |
| **Class-Based WFQ (CBWFQ)** | 管理员定义类，每类保证最小带宽 | 知道概念 |
| **Low Latency Queuing (LLQ)** | CBWFQ + 严格优先级队列 | **必须掌握** |

**LLQ 是 CCNA 的考试重点**：

- LLQ = CBWFQ 的基础上，额外增加了一个 **Priority Queue（优先队列）**
- 语音流量放入 Priority Queue，被绝对优先发送
- Priority Queue 有带宽上限（policing），防止饿死其他流量
- 其他流量按 CBWFQ 的带宽保证排队

### 附加机制：Congestion Avoidance（拥塞避免）

在队列满之前就开始主动丢包，避免 TCP 全局同步（所有 TCP 流同时降速又同时恢复）。

| 机制 | 说明 |
| --- | --- |
| **Tail Drop** | 队列满了直接丢弃新到的包（默认行为，有 TCP 全局同步问题） |
| **RED (Random Early Detection)** | 队列开始填充时随机丢包 |
| **WRED (Weighted RED)** | 基于 DSCP/IP Precedence 值决定丢包概率，低优先级先丢 |

**考试常问**：什么机制能避免 TCP Global Synchronization？答案是 **WRED**。

### 附加机制：Policing vs Shaping（流量管控）

| 特性 | Policing | Shaping |
| --- | --- | --- |
| 超速时的动作 | **丢弃**（或重标记） | **缓存延后发送** |
| 方向 | 入方向或出方向 | 通常只在出方向 |
| 流量曲线 | 有突发尖峰 | 平滑 |
| 典型场景 | ISP 对客户限速 | 客户端匹配 ISP 限速 |

**考试常考对比题**：Policing 丢弃超额流量，Shaping 延迟发送超额流量。

---

## 4. DiffServ

### 为什么需要 DiffServ？

先回到最原始的状态。IP 网络在设计之初，所有数据包都是**平等的**。路由器收到包，按 FIFO（先进先出）排队转发，不管你是语音包还是下载包，谁先到谁先走。

这就是 **Best Effort（尽力而为）** 模型。网络不给任何流量任何承诺。

这在早期互联网没问题，因为当时主要跑的是邮件、网页这类对延迟不敏感的流量。但是后来网络上开始跑语音（VoIP）和视频了，问题就来了：

- 你正在打 VoIP 电话，同时有人在同一条链路上下载大文件
- 链路拥塞了，路由器队列满了
- 路由器不分青红皂白，你的语音包和别人的下载包一起排队
- 语音包被延迟了 500ms，或者直接被丢了
- 你听到的就是断断续续的声音，甚至直接掉线

**根本矛盾**：不同类型的流量对网络质量的要求完全不同，但 Best Effort 模型把它们一视同仁。

所以需要一种机制，**让网络能区别对待不同流量**。这就是 QoS 要解决的问题。而 DiffServ 就是目前最主流的 QoS 实现方案。

### 在 DiffServ 之前，有过什么方案？

在 DiffServ 出现之前，IETF 先提出了一个叫 **IntServ（Integrated Services）** 的方案。理解 IntServ 的失败，你才能真正明白 DiffServ 为什么这样设计。

#### IntServ 的思路

IntServ 的想法很直觉：既然语音通话需要保证质量，那就**提前在整条路径上预留资源**。

具体做法：

1. 语音通话发起前，先发一个 RSVP（Resource Reservation Protocol）信令
2. 这个信令沿着从源到目的的每一跳路由器走一遍
3. 每台路由器收到 RSVP 请求后，检查自己是否有足够资源（带宽、队列空间）
4. 如果有，就**预留**出来，专门给这条语音流用
5. 整条路径上所有路由器都预留成功后，通话才开始
6. 通话期间，这些预留的资源不会被其他流量占用

这就像你去电影院，**提前买了指定座位的票**。不管电影院多满，你的座位永远给你留着。

#### IntServ 为什么失败了

听起来很完美，但有一个致命问题：**扩展性极差**。

想象一下一台核心路由器，同时有 10 万条语音通话经过它。IntServ 要求这台路由器：

- 为每一条通话维护单独的预留状态
- 记住"第 37,284 条流预留了 64kbps 带宽"
- 记住"第 89,001 条流预留了 128kbps 带宽"
- 每来一个新请求，都要检查、计算、决定是否接受
- 通话结束后还要释放状态

10 万条流 = 10 万条状态记录。100 万条流 = 100 万条记录。路由器的内存和 CPU 根本扛不住。

**IntServ 的核心缺陷：它要求每台路由器维护"每条流"（per-flow）的状态，这在大规模网络中不可行。**

### DiffServ 怎么解决 IntServ 的问题？

DiffServ 的核心设计思想就一句话：

**不再为每条流单独做保证，而是把流量分成几个"类"，对每个类统一处理。**

这就是 "Differentiated" 这个词的含义——**差异化**。不是每条流都不同（那是 IntServ），而是把流量**分成有限的几个等级**，每个等级享受不同的待遇。

DiffServ 的代价是：**它不能像 IntServ 那样给每条流做绝对保证**。但这个代价是值得的，因为它能在真实的大规模网络中实际部署。

### DiffServ 具体怎么工作？

DiffServ 的工作流程分三步。按数据包的生命周期来讲。

#### 第一步：在网络边缘，对数据包做分类和标记

**位置**：网络边缘设备（通常是接入层交换机或边界路由器）

**做什么**：

1. 数据包进入网络
2. 边缘设备检查这个包属于什么流量（语音？视频？普通数据？）
3. 根据检查结果，在包的 **IP 头部写入一个 DSCP 值**

DSCP 值写在 IP header 的哪里？在 **DS 字段（原 ToS 字段）的前 6 bits**：

```
IP Header 的 ToS 字段（8 bits）:

┌─────────────────┬──────┐
│  DSCP (6 bits)  │ECN(2)│
└─────────────────┴──────┘

DSCP 取值范围：0 - 63（2^6 = 64 种可能）
```

比如：
- 这个包是语音包 → 标记 DSCP = 46（EF）
- 这个包是视频包 → 标记 DSCP = 34（AF41）
- 这个包是普通网页 → 不标记，DSCP 保持 0（DF）

**关键设计**：标记只做一次，在边缘做。标记完之后，这个 DSCP 值就跟着 IP 包走遍整个网络。

#### 第二步：在网络核心，每台路由器根据 DSCP 值执行对应的转发行为

**位置**：路径上的每一台路由器/交换机

**做什么**：

1. 路由器收到数据包
2. 读取 IP 头部的 DSCP 值
3. 根据 DSCP 值，把这个包放入对应的队列
4. 按照预设的队列调度策略转发

路由器 **不需要知道这个包属于哪条流，不需要维护任何流状态**。它只需要看一个数字（DSCP），然后做一个动作（放入对应队列）。

这就是 DiffServ 扩展性好的根本原因：**核心设备的工作极其简单——读 DSCP，查表，放队列。**

这个"根据 DSCP 值执行的转发行为"有一个专门的术语，叫 **PHB（Per-Hop Behavior，逐跳行为）**。

"Per-Hop" 的意思是：每一跳路由器独立做决定，不需要跟前后路由器协商。

#### 第三步：在出接口拥塞时，按优先级区别对待

如果出接口没有拥塞（带宽足够），所有队列的包都能正常发出去，QoS 实际上不起作用。

**QoS 只在拥塞时才真正起作用。**

拥塞时，调度器按规则决定：

- Priority Queue（EF 流量）的包先发
- CBWFQ 队列（AF 流量）的包按权重分配带宽
- 默认队列（DF 流量）的包用剩余带宽

---

## 5. PHB（Per-Hop Behavior）

路由器收到一个数据包，要从出接口转发出去。现在出接口拥塞了，队列里已经堆了很多包。

路由器面临一个决定：**这个新来的包，我怎么对待它？**

"怎么对待"具体包含这些决定：

- 放进哪个队列？（高优先级队列？普通队列？）
- 多快把它发出去？（优先发？等别人发完再发？）
- 拥塞严重时丢不丢它？（先丢它？还是先丢别的包？）

**这一整套"对待方式"，就是 PHB。**

PHB = Per-Hop Behavior = 逐跳行为 = **一台设备对一个数据包的处理方式**。

### 路由器怎么决定用哪种"对待方式"？

靠 **DSCP 值**。

数据包的 IP 头里有一个 DSCP 字段（6 bits），里面写着一个数字（0-63）。路由器读到这个数字，就知道该怎么对待这个包。

这个关系就是：

```
DSCP 值  →  决定了  →  PHB（对待方式）
```

就这么简单。DSCP 是写在包头里的**标签**，PHB 是路由器看到标签后执行的**动作**。

### 医院急诊室类比

假设一家医院的急诊室，每个病人到了之后手腕上会绑一个**颜色标签**：

- 红色标签 = 立刻抢救，所有资源优先给他
- 黄色标签 = 尽快处理，保证在一定时间内看上医生
- 绿色标签 = 排队等着，有空了再看

这里面：

| 医院场景 | 对应 DiffServ |
| --- | --- |
| 手腕上的颜色标签 | **DSCP 值**（写在包头里的数字） |
| 医院对该颜色的处理规则（立刻抢救 / 尽快处理 / 排队等） | **PHB（逐跳行为）** |

**标签是标签，规则是规则。标签决定了适用哪条规则。**

### DiffServ 定义的三种标准 PHB

整个 DiffServ 体系就定义了三种标准的"对待方式"：

#### PHB 一：DF（Default Forwarding）

**对应 DSCP = 0**

路由器的行为：

- 放进默认队列
- 别的队列先发，有剩余带宽才轮到你
- 拥塞时你最先被丢

一句话：**没人管你，排队等着，能发就发，发不了就丢。**

#### PHB 二：EF（Expedited Forwarding）

**对应 DSCP = 46**

路由器的行为：

- 放进最高优先级队列（Priority Queue）
- **优先于所有其他流量发送**
- 几乎不排队，几乎不丢包
- 但有带宽上限，防止独占链路

一句话：**VIP 通道，插队到最前面，立刻发送。**

#### PHB 三：AF（Assured Forwarding）

**对应 DSCP = 10, 12, 14, 18, 20, 22, 26, 28, 30, 34, 36, 38（共 12 个值）**

路由器的行为：

- 放进有带宽保证的队列
- 不像 EF 那样绝对优先，但保证一个最低带宽
- 拥塞严重时会丢一些，但比 DF 好得多

一句话：**有保障但不是最优先，至少饿不死。**

### 为什么叫"Per-Hop"（逐跳）？

这是很多人困惑的地方。"Per-Hop" 的意思是：**每一台路由器独立做决定，不需要跟其他路由器协商。**

一个数据包从源到目的，经过 5 台路由器：

```
包 → [R1] → [R2] → [R3] → [R4] → [R5] → 到达目的
```

每台路由器做的事情是一样的：

1. 收到包
2. 读 DSCP 值
3. 根据 DSCP 值执行对应的 PHB（放入对应队列、按对应优先级发送）
4. 转发到下一跳

R1 不需要告诉 R2 "我对这个包做了什么"。R2 也不需要问 R1。每台路由器只看包头里的 DSCP 值，**独立决定怎么对待这个包**。

这就是 "Per-Hop" 的含义：决策在每一跳独立发生。

这也是 DiffServ 和 IntServ 的根本区别：

|  | IntServ | DiffServ |
| --- | --- | --- |
| 路由器之间需要协商吗 | 需要（RSVP 信令沿路径协商） | **不需要** |
| 每台路由器怎么做决定 | 查自己维护的流状态表 | **只看 DSCP 值** |
| 所以叫什么 | 端到端预留 | **Per-Hop Behavior（逐跳行为）** |

### 完整对应关系总结

```
数据包进入网络
    │
    ▼
边缘设备检查流量类型，写入 DSCP 值
    │
    ├── 语音 → DSCP 写入 46
    ├── 视频 → DSCP 写入 34
    └── 普通 → DSCP 保持 0
    │
    ▼
每台路由器收到包后，读 DSCP 值，执行对应 PHB：
    │
    ├── 读到 DSCP 46 → 执行 EF → 放入 Priority Queue → 立刻发
    ├── 读到 DSCP 34 → 执行 AF → 放入带宽保证队列 → 保证发
    └── 读到 DSCP 0  → 执行 DF → 放入默认队列 → 有空再发
```

**DSCP 是标签，PHB 是动作。路由器看标签，做动作。每一跳都这样做。这就是 PHB 的全部。**

---

## 6. EF、AF、DF 详解

网络里跑着各种各样的流量。有些流量很"娇贵"（语音），有些流量很"皮实"（文件下载）。

DiffServ 的做法是：**给流量分等级，不同等级享受不同待遇。**

一共就分了三个等级。这三个等级就是 EF、AF、DF。

**它们就是三个等级的名字，仅此而已。** 就像酒店分五星、三星、快捷酒店，EF/AF/DF 就是网络流量的"星级"。

### DF = Default Forwarding = 默认转发

**DSCP 值 = 0**

DF 的意思就是：**这个包没有任何特殊身份，网络对它没有任何承诺。**

路由器对 DF 流量的态度：

- 有带宽就转发
- 没带宽就排队
- 队列满了就丢掉
- 不保证延迟，不保证带宽，不保证不丢

**什么流量是 DF？**

所有没有被管理员特别标记的流量都是 DF。也就是说，如果你的网络完全没有配置 QoS，那网络里 100% 的流量都是 DF。

具体例子：员工刷网页、下载文件、收发邮件、看新闻。这些流量对网络质量没有严格要求，晚几百毫秒到达用户根本感觉不到。

**DF 的本质：普通流量，没有特权。**

### EF = Expedited Forwarding = 加速转发

**DSCP 值 = 46**

"Expedited" 这个英文单词的意思是"加急、加速"。EF 就是网络里的**最高优先级**。

路由器对 EF 流量的态度：

- 收到就立刻发送，不让它等
- 给它专门的队列（Priority Queue），这个队列永远比其他队列先处理
- 尽一切可能保证：低延迟、低抖动、低丢包

**什么流量用 EF？**

**语音（VoIP）。** 基本上只有语音用 EF。

为什么语音需要这么高的优先级？因为语音有三个特殊要求：

1. **延迟必须低**：你说一句话，对方 0.15 秒内必须听到，否则对话节奏就乱了
2. **抖动必须小**：每个语音包的到达间隔必须稳定，否则声音会忽快忽慢
3. **丢包必须少**：丢一个语音包，对方就听到一个"咔嗒"或者空白

这三个要求，只有最高优先级的转发才能满足。所以语音用 EF。

**但是 EF 有一个限制**：管理员会给 EF 流量设一个**带宽上限**。比如 100Mbps 的链路，EF 最多用 20Mbps。

为什么要限制？因为如果 EF 可以无限占带宽，万一语音流量突然暴增，它会把整条链路占满，其他所有流量（视频、业务系统）全部饿死。所以 EF 虽然优先级最高，但总量是被控制的。

**EF 的本质：VIP 中的 VIP，但有人数限制。**

### AF = Assured Forwarding = 保证转发

**DSCP 值 = 10 到 38 之间的 12 个值**

AF 比 DF 好，但不如 EF。它的含义是：**网络对这类流量提供一定程度的保证，但不是绝对优先。**

路由器对 AF 流量的态度：

- 给它分配一个**有最低带宽保证的队列**
- 就算网络拥塞，也保证它至少能拿到这么多带宽
- 但它不能插队到 EF 前面
- 拥塞特别严重时，AF 的一部分包也可能被丢

**什么流量用 AF？**

比普通流量重要、但没有语音那么苛刻的流量：

- 视频会议（对延迟有一定要求，但没语音那么极端）
- 企业核心业务系统（ERP、CRM、数据库同步等）
- 重要的文件传输

#### AF 为什么有 12 个值？

这是 AF 比 EF 和 DF 复杂的地方。AF 内部做了更细的划分。

AF 分成了 **4 个类（Class）** 和 **3 个丢弃优先级（Drop Precedence）**，组合起来就是 4 × 3 = 12 种。

**先理解 4 个类（Class 1-4）：**

Class 代表**转发优先级**。Class 越大，路由器给它分配的带宽保证越高。

```
Class 4：带宽保证最高    ← 视频会议通常放这里
Class 3：带宽保证次高    ← 重要业务应用
Class 2：带宽保证中等
Class 1：带宽保证最低    ← 普通但需要一定保证的流量
```

**再理解 3 个丢弃优先级（Drop 1-3）：**

在同一个 Class 里，如果拥塞了需要丢包，先丢谁？

```
Drop 1：最不容易被丢（低丢弃概率）
Drop 2：中等概率被丢
Drop 3：最容易被丢（高丢弃概率）
```

**组合起来看：**

以 AF4 这个 Class 为例（最高转发优先级的 Class）：

| 名称 | DSCP 值 | 含义 |
| --- | --- | --- |
| AF41 | 34 | Class 4，拥塞时最不容易被丢 |
| AF42 | 36 | Class 4，拥塞时中等概率被丢 |
| AF43 | 38 | Class 4，拥塞时最容易被丢 |

它们三个都在同一个队列里（Class 4 的队列），享受同样的带宽保证。区别只是：**当这个队列内部也拥塞了，AF43 的包先被丢，AF41 的包最后被丢。**

#### AF 命名规则

AFxy 中：

- x = Class 编号（1-4）
- y = Drop 编号（1-3）

DSCP 值 = 8 × x + 2 × y

举例验证：

- AF41 = 8×4 + 2×1 = 34 ✓
- AF23 = 8×2 + 2×3 = 22 ✓
- AF11 = 8×1 + 2×1 = 10 ✓

**AF 的本质：中产阶级，有保障但不是最优先。内部还分了细级别。**

### 三者的完整对比

|  | DF | AF | EF |
| --- | --- | --- | --- |
| 全称 | Default Forwarding | Assured Forwarding | Expedited Forwarding |
| DSCP 值 | 0 | 10-38（12个值） | 46 |
| 优先级 | **最低** | **中** | **最高** |
| 带宽保证 | 无 | 有最低保证 | 优先发送 + 带宽上限 |
| 拥塞时丢包 | 最先被丢 | 部分被丢（按 Drop 等级） | 几乎不丢 |
| 典型流量 | 网页、邮件、下载 | 视频、业务系统 | 语音 |
| 复杂度 | 最简单，就一个值 | 最复杂，12 个值 | 简单，就一个值 |

### 用一个场景把三个等级串起来

一条 100Mbps 的链路，三种流量同时在跑：

```
语音 (EF, DSCP 46) ——→ 需要 10Mbps
视频 (AF41, DSCP 34) —→ 需要 40Mbps
网页 (DF, DSCP 0) ——→ 需要 80Mbps
                        总计 130Mbps > 链路容量 100Mbps
                        拥塞了！
```

路由器怎么处理：

**第一步**：EF 的 10Mbps 全额满足。语音通话完全不受影响。剩余 90Mbps。

**第二步**：AF41 保证最低带宽（假设配了 30Mbps）。视频至少拿到 30Mbps，可能更多。假设实际拿到 40Mbps。剩余 50Mbps。

**第三步**：DF 拿到剩下的 50Mbps。它本来需要 80Mbps，现在只有 50Mbps，所以有 30Mbps 的流量被丢弃或延迟。员工感觉网页打开变慢了。

**结论**：语音完好，视频尚可，网页变慢。这就是 DiffServ 用 EF/AF/DF 三级分类实现的效果。

---

## 7. AF 的 DSCP 值 bit 结构详解

### 第一步：DSCP 是一个 6-bit 的数字

IP 头部有一个 DS 字段，其中前 6 个 bit 就是 DSCP：

```
bit位:  5  4  3  2  1  0
```

6 个 bit，最大值 = 111111（二进制）= 63（十进制），所以 DSCP 取值范围是 0-63。

### 第二步：AF 把这 6 个 bit 分成了两段

AF 的设计者规定，这 6 个 bit 这样使用：

```
┌──────────────┬───────────┬───┐
│  Class (3bit)│  Drop(2bit)│ 0 │
│  bit 5,4,3   │  bit 2,1   │bit0│
└──────────────┴───────────┴───┘
```

- **前 3 个 bit（bit 5、4、3）**：表示 Class 编号（1-4）
- **中间 2 个 bit（bit 2、1）**：表示 Drop 编号（1-3）
- **最后 1 个 bit（bit 0）**：固定为 0，不使用

这就是 AF 的全部结构。下面一个一个展开。

### 第三步：用具体例子拆解

#### 例子 1：AF11（Class 1，Drop 1）

```
Class = 1 → 二进制 001 → 放在 bit 5,4,3
Drop  = 1 → 二进制  01 → 放在 bit 2,1
固定                  0 → 放在 bit 0

拼起来：0 0 1 0 1 0
        ─────── ───── ─
        Class=1 Drop=1 固定0

转十进制：001010 = 0×32 + 0×16 + 1×8 + 0×4 + 1×2 + 0×1
                = 8 + 2
                = 10
```

**AF11 = DSCP 10** ✓

#### 例子 2：AF41（Class 4，Drop 1）

```
Class = 4 → 二进制 100 → 放在 bit 5,4,3
Drop  = 1 → 二进制  01 → 放在 bit 2,1
固定                  0 → 放在 bit 0

拼起来：1 0 0 0 1 0
        ─────── ───── ─
        Class=4 Drop=1 固定0

转十进制：100010 = 1×32 + 0×16 + 0×8 + 0×4 + 1×2 + 0×1
                = 32 + 2
                = 34
```

**AF41 = DSCP 34** ✓

#### 例子 3：AF23（Class 2，Drop 3）

```
Class = 2 → 二进制 010 → 放在 bit 5,4,3
Drop  = 3 → 二进制  11 → 放在 bit 2,1
固定                  0 → 放在 bit 0

拼起来：0 1 0 1 1 0
        ─────── ───── ─
        Class=2 Drop=3 固定0

转十进制：010110 = 0×32 + 1×16 + 0×8 + 1×4 + 1×2 + 0×1
                = 16 + 4 + 2
                = 22
```

**AF23 = DSCP 22** ✓

### 第四步：公式是怎么来的

你已经看到了规律：

- Class 占 bit 5、4、3，也就是说 Class 的值被放在了"第 3 位起"的位置
- 一个数字放在 bit 3 的位置，等于这个数字 **× 8**（因为 2³ = 8）
- Drop 占 bit 2、1，也就是说 Drop 的值被放在了"第 1 位起"的位置
- 一个数字放在 bit 1 的位置，等于这个数字 **× 2**（因为 2¹ = 2）

所以：

```
DSCP = Class × 8 + Drop × 2
```

这个公式不是凭空规定的，**它就是 bit 结构的直接数学表达**。

验证所有 12 个 AF 值：

| AF名称 | Class | Drop | 8×Class + 2×Drop | DSCP |
| --- | --- | --- | --- | --- |
| AF11 | 1 | 1 | 8+2 | **10** |
| AF12 | 1 | 2 | 8+4 | **12** |
| AF13 | 1 | 3 | 8+6 | **14** |
| AF21 | 2 | 1 | 16+2 | **18** |
| AF22 | 2 | 2 | 16+4 | **20** |
| AF23 | 2 | 3 | 16+6 | **22** |
| AF31 | 3 | 1 | 24+2 | **26** |
| AF32 | 3 | 2 | 24+4 | **28** |
| AF33 | 3 | 3 | 24+6 | **30** |
| AF41 | 4 | 1 | 32+2 | **34** |
| AF42 | 4 | 2 | 32+4 | **36** |
| AF43 | 4 | 3 | 32+6 | **38** |

### 第五步：反向推导（考试会考）

考试可能给你一个 DSCP 值，让你反推 AF 名称。

**例子：DSCP = 28，是哪个 AF？**

```
第一步：28 ÷ 8 = 3 余 4     → Class = 3
第二步：4 ÷ 2 = 2            → Drop = 2
答案：AF32
```

**例子：DSCP = 14，是哪个 AF？**

```
第一步：14 ÷ 8 = 1 余 6     → Class = 1
第二步：6 ÷ 2 = 3            → Drop = 3
答案：AF13
```

**例子：DSCP = 34，是哪个 AF？**

```
第一步：34 ÷ 8 = 4 余 2     → Class = 4
第二步：2 ÷ 2 = 1            → Drop = 1
答案：AF41
```

### 总结

```
AF 的 DSCP 值 = Class × 8 + Drop × 2

原因：6个bit的结构是 [Class 3bit][Drop 2bit][0 1bit]
     Class 在高位，乘以 8（2³）
     Drop 在中位，乘以 2（2¹）
     最低位固定为 0
```

![[ip-header-dscp.html]]
